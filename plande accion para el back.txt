0) Principio rector (para que funcione en producción)

La IA NO toca lógica de booking: solo orquesta llamadas a tu motor existente.

Tu backend es la única fuente de verdad para: disponibilidad, precio, políticas, cancelación, impuestos, reglas, inventario.

“Web/Contexto” (clima/places/reseñas) es informativo y siempre separado del flujo de compra.

1) Crear el módulo “AI Orchestrator” (aislado)

Objetivo: encapsular toda la IA y herramientas en una carpeta/servicio interno, sin contaminar el resto del sistema.

1.1 Estructura sugerida (conceptual)

src/modules/ai/

ai.routes.js (endpoints)

ai.controller.js

ai.service.js (orquestación)

ai.planner.js (intención + slots + next action)

ai.renderer.js (texto + UI payload)

ai.tools/ (wrappers hacia tus servicios)

tool.searchStays.js (usa tu motor)

tool.getStayDetails.js

tool.quoteBooking.js

tool.createBooking.js

tool.geocode.js

tool.weather.js

tool.places.js

ai.policy.js (guardrails y reglas)

ai.stateStore.js (persistencia del estado conversacional)

ai.telemetry.js (logs, métricas, tracing)

Regla: nada fuera de este módulo debe saber cómo se llama el modelo o cómo funciona el prompt.

2) Persistencia de estado conversacional (crítico)

Objetivo: que el chat sea “inteligente” sin depender de memoria del modelo.

2.1 Crear entidades/tablas (o colección) para estado

Crear algo tipo:

ai_conversations

id (uuid)

user_id

status (active/closed)

created_at, updated_at

ai_messages

id, conversation_id, role (user/assistant/system)

content_text

content_structured (json)

created_at

ai_conversation_state

conversation_id

state_json (jsonb) con:

destination: { name, placeId, lat, lon, timezone, bbox, confidence }

dates: { checkIn, checkOut, flexible?, originalText? }

rooms: number

guests: { adults, children, childrenAges? }

budget: { min, max, currency }

preferences: { amenities[], areas[], cancellationPolicy?, propertyType? }

lastResultsContext: { lastSearchId, shownIds[] }

stage: NEED_DESTINATION | NEED_DATES | SHOW_RESULTS | DETAILS | QUOTE | READY_TO_BOOK | BOOKED

locks: { bookingFlowLocked: boolean } (para impedir web cuando está en checkout)

Regla de oro: el planner solo decide “qué hacer”, pero el state es lo que manda.

3) Endpoint principal del chat (un solo entrypoint)

Crear un endpoint único (interno para app):

POST /api/ai/chat

3.1 Request esperado

conversationId? (si no viene, se crea)

message (texto user)

locale, currency, appVersion, platform

userContext mínimo (userId, isLoggedIn, role)

opcional: uiEvent cuando el user toca chips/cards (ej: “FILTER_CHEAP”, “OPEN_STAY:123”)

3.2 Response uniforme (muy importante para tu app grande)

Responder siempre con un payload estable:

{
  "conversationId": "...",
  "assistant": {
    "text": "...",
    "tone": "neutral",
    "disclaimers": []
  },
  "ui": {
    "chips": [{ "id": "REFINE_CHEAP", "label": "Más barato" }],
    "cards": [{ "type": "stay", "id": "...", "title": "...", "priceFrom": 0, "meta": {} }],
    "inputs": [{ "type": "dateRange", "id": "DATES", "required": true }],
    "sections": [
      { "type": "booking", "items": [...] },
      { "type": "context", "items": [...] }
    ]
  },
  "state": { "stage": "...", "destination": {...}, "dates": {...} }
}


Regla: la app renderiza UI desde ui.*, no desde “interpretar el texto”.

4) Planner (intención → plan → acciones)

Objetivo: convertir texto libre en acciones determinísticas.

4.1 Planner retorna un JSON estricto

El planner SIEMPRE retorna:

intent: SEARCH | REFINE | OPEN_DETAILS | QUOTE | BOOK | INFO | SUPPORT | SMALL_TALK

slots: destination, dates, rooms, budget, etc.

missing: lista de campos faltantes prioritarios

nextAction: una de estas:

ASK_FOR_DATES

ASK_FOR_ROOMS

RUN_SEARCH

SHOW_DETAILS

RUN_QUOTE

CONFIRM_BOOKING

RUN_CONTEXT_ENRICHMENT

safeMode: boolean (true si estamos en etapa sensible)

4.2 Guardrails del planner (en ai.policy)

Si stage está en QUOTE/READY_TO_BOOK:

intent permitido: QUOTE | BOOK | SUPPORT

web/contexto bloqueado

Si el user pide “precio final / disponibilidad”:

debe ir a tool interna (search/quote) sí o sí

Si faltan fechas:

1 pregunta máximo por turno, y preferir UI input (calendario)

5) Tools: wrappers hacia tu motor existente (lo más importante)

Objetivo: Codex no debe reescribir booking. Solo envolverlo.

5.1 Tools “Booking Truth”

Implementar wrappers que llamen directamente a tus servicios/repos actuales:

tool.searchStays(filters)
Internamente:

decide home/hotel (o ambos)

llama tus servicios de búsqueda existentes

normaliza resultados a un “StayCardModel” común (home/hotel)

retorna: array de cards + metadata (currency, bounds, searchId)

tool.getStayDetails(stayId, type)
trae detalles completos para pantalla

tool.quoteBooking(stayId, dates, rooms, guests, options)
usa tu flujo de quote / pre-book / getRooms / pricing real.

tool.createBooking(quoteId, paymentIntentId, guestData)
llama tu booking pipeline actual (con tus validaciones)

Regla: cada tool debe ser 100% idempotente o tener idempotency key explícita.

5.2 Tools “Context Only” (geocode/weather/places)

tool.geocode(placeText)
Debe devolver lat/lon + placeId + bbox + confidence.

tool.weather(lat, lon, dateRange)
Devuelve forecast resumido (no 50 campos).

tool.places(lat, lon, categories, radius, limit)
Devuelve lugares cercanos y ratings agregados.

Regla: estos tools nunca se mezclan con precio/disponibilidad y nunca condicionan el booking.

6) Orquestación del flujo (la “máquina de estados”)

Objetivo: que el sistema sea predecible.

Implementar un handler que siga este pipeline:

Paso A: cargar estado

si no existe conversation → crear + state inicial

cargar state_json

Paso B: planner

pasar (message + state + userContext)

recibir plan

Paso C: aplicar slots al estado

merge controlado (no sobreescribir cosas confirmadas sin intención del user)

normalizar fechas (“esta semana” → pedir UI o resolver con helper)

Paso D: ejecutar nextAction

ASK_FOR_* → devolver ui.inputs apropiados

RUN_SEARCH → ejecutar tool.searchStays, guardar lastResultsContext, devolver cards

SHOW_DETAILS → tool.getStayDetails

RUN_QUOTE → tool.quoteBooking, devolver resumen + warnings/policies

CONFIRM_BOOKING → validar confirmación explícita + tool.createBooking

RUN_CONTEXT_ENRICHMENT → weather + places y devolver como sección “context”

Paso E: renderer

generar assistant.text corto y útil

poblar ui.* estable

Paso F: persistir todo

guardar mensaje user

guardar mensaje assistant (text + structured)

guardar state actualizado

7) UX backend-driven (para que sea “simple y rápida”)

El backend debe producir “acciones rápidas” siempre:

7.1 Chips / Quick actions

Generar chips según contexto:

“Más barato”

“Mejor ubicación”

“Cancelación flexible”

“Cerca de playa”

“Homes con cocina”

“Hoteles 4+ estrellas”

“3 habitaciones reales” (ojo: multiroom)

Cada chip debe mapear a uiEvent que tu endpoint entiende y convierte en filtros, sin pasar por “interpretación” de texto.

7.2 Carriles (shortlist)

Devolver resultados agrupados:

bestPrice[]

bestLocation[]

bestValue[]

Aunque sean heurísticas simples, se sienten inteligentes y aceleran decisión.

8) Seguridad, costos, y control de calidad (no negociable)
8.1 Rate limiting + cuotas

rate limit por user + por IP (chat puede ser caro)

límite de tokens/respuesta

máximo N tools por turno (ej: 3)

8.2 Caching

geocode cache (por ciudad/consulta)

weather cache (por lat/lon + día)

places cache (por lat/lon + categoría + radio)

search results: cache corto (si tu inventario lo permite)

8.3 Observabilidad

Loggear por request:

conversationId, userId

intent, nextAction

tools ejecutadas + latencia

errores normalizados

8.4 Anti-alucinación (enforcer)

Antes de responder:

si el texto menciona precio/availability, verificar que provenga de tool interna

si menciona clima, debe venir de tool.weather

si menciona reseñas, debe venir de tool.places o fuente permitida

Si no, el renderer debe corregir o borrar ese claim.

9) Integración con tu producto “grande” (sin romper features)
9.1 No tocar flujos existentes

el chat usa los mismos servicios de search/quote/book que el resto de la app

no duplicar lógica

9.2 Feature flags

Agregar flags:

AI_CHAT_ENABLED

AI_CONTEXT_ENABLED

AI_BOOKING_ASSIST_ENABLED (quote/checkout guiado)
Permite rollout gradual.

9.3 Compatibilidad UI

El backend debe ser backward compatible:

si la app vieja no entiende sections, no se rompe: assistant.text + cards mínimo.

10) Tests obligatorios (si querés dormir tranquilo)
10.1 Unit tests (planner + policy)

Casos:

“Miami esta semana 3 habitaciones” → pide fechas

“del 10 al 15” → RUN_SEARCH

“más barato” → REFINE

“quiero reservar el 2do” → QUOTE/BOOK

si stage=QUOTE, no se permite web/context

10.2 Integration tests (tools)

Mockear providers externos (weather/places) y verificar:

caching

timeouts

fallback “sin contexto disponible”

10.3 E2E feliz

message1 → ask dates + show chips

dates → search results + context

open card → details

quote → summary

book → success

11) Reglas de conversación (para que se sienta “IA-first”)

Implementar estas reglas en renderer:

1 pregunta máximo por turno

siempre devolver algo accionable (chips o input o cards)

el texto no debe ser largo: 2–5 líneas + UI

contexto (clima/POIs) siempre en sección aparte, con lenguaje “estimado”

12) Entregable final para Codex (qué tiene que quedar funcionando)

Al terminar, Codex debe dejar:

Endpoint /api/ai/chat productivo

Persistencia de conversation/state/messages

Planner que decide intent/slots/nextAction

Tools wrappers conectados a tu booking engine

Tools contexto (geocode/weather/places) con cache + timeouts

Renderer que devuelve payload UI estable

Guardrails + telemetry + tests base

Feature flags para rollout

Si querés que Codex lo ejecute perfecto a la primera

Decile explícitamente:

“No reescribas mi booking engine”

“Implementá wrappers/tools que llaman mis servicios existentes”

“No inventes precio/availability; solo lo que retorna search/quote”

“Todo UI debe venir estructurado en JSON; la app no parsea texto”

Si me pegás cómo se llama tu servicio actual de búsqueda/booking (los nombres reales de módulos/funciones en tu backend), te lo ajusto al nivel “plug-and-play” (mismo mapa, pero reemplazando tool.searchStays por tus nombres reales y el orden correcto de llamadas en tu flujo).